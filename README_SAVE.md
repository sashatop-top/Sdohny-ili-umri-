# Дополнение к заданию: система сохранения и загрузки игры

В проект необходимо добавить сохранение и восстановление состояния игры с опорой на сериализацию через `json` (только стандартная библиотека).

## Общая идея

Игра может быть завершена пользователем в любой момент, введя команду `exit` кроме ситуации, когда игрок находится в бою. При завершении игра сохраняет прогресс в единственном слоте сохранения: `save.json`.

При следующем запуске игры игра должна определить:

- есть ли сохранение,
- на каком уровне находится игрок,
- нужно продолжить незавершённое прохождение уровня или генерировать новый.

## Уровни

Теперь в игре несколько уровней, и после завершения уровня автоматически генерируется новый.
Для каждого уровня создаётся новое игровое поле со всеми сущностями (враги, бонусы, оружие, башни).

## Поведение при выходе из игры
| Когда игрок выходит | Что сохранять |
| ------------------- | ------------- |
| не достигнут финиш | cохраняется всё состояние игры |
| уровень пройден | cохраняется только игрок и номер последнего пройденного уровня |
| игрок проиграл | cохраняется лучший результат (см. далее) |

## Система лучшего результата

Хранится информация лучшего результата в файле `record.json`:

Лучшая попытка перезаписывается, если:
1. Игрок дошёл дальше по уровню, чем предыдущий рекорд.
2. Если номер уровня совпадает, то сравнивается количество монет.
3. Если и уровень, и монеты одинаковые — рекорд не перезаписывать.

Стуктура файла:
```
{
    "max_level": 3,
    "coins": 820
}
```

## Настройки сложности

Создать отдельный файл `difficulty.json`:
```
difficulty.json
{
  "easy": {
    "board_min": 5,
    "board_max": 7,
    "enemy_multiplier": 0.1,
    "bonus_multiplier": 0.4,
    "weapon_multiplier": 0.15,
    "tower_multiplier": 0.03
  },
  "normal": {
    "board_min": 8,
    "board_max": 11,
    "enemy_multiplier": 0.2,
    "bonus_multiplier": 0.3,
    "weapon_multiplier": 0.1,
    "tower_multiplier": 0.02
  },
  "hard": {
    "board_min": 12,
    "board_max": 15,
    "enemy_multiplier": 0.4,
    "bonus_multiplier": 0.2,
    "weapon_multiplier": 0.05,
    "tower_multiplier": 0.01
  }
}
```
Где множители влияют на:
- количество врагов,
- количество бонусов,
- количество оружия,
- количество башен.

Значения указываны в долях (0.4 = 40%) от общего кол-ва клеток на поле.

Игрок при первом запуске выбирает сложность: `easy / normal / hard`.

## Размер поля

Размер поля не запрашивается у пользователя, а выбирается случайно из диапазона сложности:

| Сложность | Размер поля |
| --------- | ----------- |
| easy | случайное `N` и `M` в пределах 5–7 |
| normal | случайное `N` и `M` в пределах 8–11 |
| hard | случайное `N` и `M` в пределах 12–15 |

Поля в итоге могут быть разные, например: 5x6, 7x5, 10x8 и т.п.

## Формат файла сохранения save.json

Cтруктура файла:
```
{
  "difficulty": "normal",
  "current_level": 3,
  "player": { ... сериализованный игрок ... },
  "board": { ... сериализованное поле или null, если уровень завершён ... },
}
```

## Поведение при старте программы

1. Проверить наличие `save.json`
2. Если нет — новый старт, выбор сложности, генерация уровня №1
3. Если есть — показать сообщение:
```
Продолжение игры. Текущий уровень: X.
Введите start для продолжения или new для начала новой игры.
```
При `new` предыдущий рекорд не стирается.

## Сериализация / десериализация

Требования:
- использовать только стандартный `json`
- каждый объект, который сохраняется, должен иметь методы:
  - `to_dict()`
  - `@classmethod from_dict(cls, data)`
- тип объектов хранится явно, например, для сохранения объекта в `Board` можно сохранить так:
`{ "type": "Bow", "attrs": { "ammo": 12, "max_damage": 35 } }`

--------

_Как можно строить объекты через название класса:_

Регистрация классов, которые можно сериализовать:
```
CLASS_SERIALIZE = {}

def register_class(cls):
    CLASS_SERIALIZE[cls.__name__] = cls
    return cls
```

Использование:
```
@register_class
class Bow(RangedWeapon):
    ...
    @classmethod
    def from_dict(cls, d):
        return cls(**d)
    ...
```

Десериализация:
```
def load_object(d: dict):
    cls = CLASS_REGISTRY[d["type"]]
    return cls.from_dict(d["attrs"])
```